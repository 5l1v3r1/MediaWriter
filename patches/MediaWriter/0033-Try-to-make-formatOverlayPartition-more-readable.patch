From 40356e0004f9df81cddc17e05ff49312260c456e Mon Sep 17 00:00:00 2001
From: squimrel <squimrel@users.noreply.github.com>
Date: Wed, 23 Aug 2017 11:39:50 +0000
Subject: [PATCH 33/40] Try to make formatOverlayPartition more readable

---
 helper/blockdevice.cpp | 119 ++++++++++++++++++++++++++++++-------------------
 1 file changed, 74 insertions(+), 45 deletions(-)

diff --git a/helper/blockdevice.cpp b/helper/blockdevice.cpp
index e9ca1ce..8109b7c 100644
--- a/helper/blockdevice.cpp
+++ b/helper/blockdevice.cpp
@@ -129,9 +129,22 @@ int BlockDevice::addPartition(quint64 offset, quint64 size) {
  * Format a partition with FAT32 and add an OVERLAY.IMG file that's zeroed out.
  */
 void BlockDevice::formatOverlayPartition(quint64 offset, quint64 size) {
+    /**
+     * Magic values were generated by mkfs.fat (dosfstools).
+     */
+    constexpr quint8 bootSign[] = { 0x55, 0xaa };
+    constexpr quint8 infoSector[] = { 0x52, 0x52, 0x61, 0x41 };
+    constexpr quint8 fat[] = {
+        0xf8, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0x0f
+    };
+    constexpr quint8 fatEof[] = { 0xff, 0xff, 0xff, 0x0f };
+    constexpr std::size_t fsinfoOffset = 480;
+
     constexpr int RESERVED_SECTORS = 32;
     constexpr int NR_FATS = 2;
     constexpr quint64 FIRST_CLUSTER = 3;
+    constexpr std::array<int, 4> ranges = { { 260, 1024 * 8, 1024 * 16, 1024 * 32 } };
+
     auto align = [](quint64 number, quint64 alignment) -> quint64 {
         return (number + alignment - 1) & ~(alignment - 1);
     };
@@ -142,53 +155,58 @@ void BlockDevice::formatOverlayPartition(quint64 offset, quint64 size) {
         return (a + b - 1) / b;
     };
 
-    const int sizeMb = size / (1024 * 1024);
-    const std::array<int, 4> ranges = { { 260, 1024 * 8, 1024 * 16, 1024 * 32 } };
+    // Calulate cluster size.
+    int sizeMb = size / (1024 * 1024);
     auto found = qLowerBound(ranges.begin(), ranges.end(), sizeMb);
-    const int sectorsPerCluster = found == ranges.begin() ? 1 : (found - ranges.begin()) * 8;
-    const int clusterSize = SECTOR_SIZE * sectorsPerCluster;
-    const int numSectors = size / SECTOR_SIZE;
-    const quint64 fatdata = numSectors - RESERVED_SECTORS;
-    const quint64 clusters = (fatdata * SECTOR_SIZE + NR_FATS * 8) / (sectorsPerCluster * SECTOR_SIZE + NR_FATS * 4);
-    const quint64 fatlength = align(divCeil((clusters + 2) * 4, SECTOR_SIZE), sectorsPerCluster);
-    const quint64 headerSize = (RESERVED_SECTORS + fatlength * 2 + sectorsPerCluster) * SECTOR_SIZE;
+    int sectorsPerCluster = found == ranges.begin() ? 1 : (found - ranges.begin()) * 8;
+    int clusterSize = SECTOR_SIZE * sectorsPerCluster;
+
+    // Calculate length of fat cluster allocation table.
+    quint64 numSectors = size / SECTOR_SIZE;
+    quint64 fatdata = numSectors - RESERVED_SECTORS;
+    quint64 clusters = (fatdata * SECTOR_SIZE + NR_FATS * 8) / (clusterSize + NR_FATS * 4);
+    quint64 fatlength = align(divCeil((clusters + 2) * 4, SECTOR_SIZE), sectorsPerCluster);
+
+    // Calculate values that are dependend of the overlay file size.
+    quint64 headerSize = (RESERVED_SECTORS + fatlength * 2 + sectorsPerCluster) * SECTOR_SIZE;
     quint64 maxFileSize = std::min(size - headerSize, 0xffffffffULL);
     maxFileSize = align(maxFileSize - SECTOR_SIZE - 1, SECTOR_SIZE);
-    const quint64 nextFreeCluster = FIRST_CLUSTER + (maxFileSize / clusterSize) + 1;
-    const quint64 numFreeClusters = ((size - headerSize) / clusterSize) + 1;
-    /**
-     * Magic values were generated by mkfs.fat (dosfstools).
-     */
-    constexpr quint8 bootSign[] = { 0x55, 0xaa };
-    constexpr quint8 infoSector[] = { 0x52, 0x52, 0x61, 0x41 };
-    constexpr std::size_t fsinfoOffset = 480;
+    quint64 fileZeros = std::min(maxFileSize, 64ULL * 1024ULL);
+    quint64 nextFreeCluster = FIRST_CLUSTER + (maxFileSize / clusterSize) + 1;
+    quint64 numFreeClusters = ((size - headerSize) / clusterSize) + 1;
+
     auto fc = [&numFreeClusters, &getbyte](int i) {
         return getbyte(numFreeClusters, i);
     };
     auto nc = [&nextFreeCluster, &getbyte](int i) {
         return getbyte(nextFreeCluster, i);
     };
-    const quint8 fsinfo[] = {
+    quint8 fsinfo[] = {
+        // Info sector signature.
         0x72, 0x72, 0x41, 0x61,
+        // Number of free clusters.
         fc(0), fc(1), fc(2), fc(3),
+        // Next free cluster.
         nc(0), nc(1), nc(2), nc(3)
     };
-    constexpr quint8 fat[] = {
-        0xf8, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0x0f
-    };
-    constexpr quint8 fatEof[] = { 0xff, 0xff, 0xff, 0x0f };
     auto t = [&numSectors, &getbyte](int i) {
         return getbyte(numSectors, i);
     };
     auto f = [&fatlength, &getbyte](int i) {
         return getbyte(fatlength, i);
     };
-    const quint32 volumeId = QDateTime::currentMSecsSinceEpoch() & 0xffffffff;
+    // Generate UUID from time. This is similar to how mkfs.fat does it.
+    quint32 volumeId = QDateTime::currentMSecsSinceEpoch() & 0xffffffff;
     auto u = [&volumeId, &getbyte](int i) {
         return getbyte(volumeId, i);
     };
-    const quint8 clsz = sectorsPerCluster;
-    const quint8 bootSector[] = { 0xeb, 0x58, 0x90, 0x6d, 0x6b, 0x66, 0x73,
+    quint8 clsz = sectorsPerCluster;
+    /**
+     * Contains information like the fat label and other fixed values generated
+     * by mkfs.fat. Values that can change are described by variable names
+     * above.
+     */
+    quint8 bootSector[] = { 0xeb, 0x58, 0x90, 0x6d, 0x6b, 0x66, 0x73,
         0x2e, 0x66, 0x61, 0x74, 0x00, 0x02, clsz, 0x20, 0x00, 0x02, 0x00, 0x00,
         0x00, 0x00, 0xf8, 0x00, 0x00, 0x3e, 0x00, 0xf7, 0x00, 0x00, 0x00, 0x00,
         0x00, t(0), t(1), t(2), t(3), f(0), f(1), f(2), f(3), 0x00, 0x00, 0x00,
@@ -196,7 +214,9 @@ void BlockDevice::formatOverlayPartition(quint64 offset, quint64 size) {
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x29,
         u(0), u(1), u(2), u(3), 0x4f, 0x56, 0x45, 0x52, 0x4c, 0x41, 0x59, 0x20,
         0x20, 0x20, 0x20, 0x46, 0x41, 0x54, 0x33, 0x32, 0x20, 0x20, 0x20 };
-    const quint8 bootCode[] = { 0x0e, 0x1f, 0xbe, 0x77, 0x7c, 0xac, 0x22, 0xc0,
+    // Will display an error message in case someone tries to boot from this
+    // partition.
+    quint8 bootCode[] = { 0x0e, 0x1f, 0xbe, 0x77, 0x7c, 0xac, 0x22, 0xc0,
         0x74, 0x0b, 0x56, 0xb4, 0x0e, 0xbb, 0x07, 0x00, 0xcd, 0x10, 0x5e, 0xeb,
         0xf0, 0x32, 0xe4, 0xcd, 0x16, 0xcd, 0x19, 0xeb, 0xfe, 0x54, 0x68, 0x69,
         0x73, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x20, 0x62,
@@ -209,21 +229,32 @@ void BlockDevice::formatOverlayPartition(quint64 offset, quint64 size) {
         0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x20, 0x2e, 0x2e, 0x2e, 0x20, 0x0d,
         0x0a };
     constexpr std::size_t bootCodeSize = 420;
-    const auto datetime = QDateTime::currentDateTimeUtc();
-    const auto timeOnly = datetime.time();
-    const auto dateOnly = datetime.date();
+    auto datetime = QDateTime::currentDateTimeUtc();
+    auto timeOnly = datetime.time();
+    auto dateOnly = datetime.date();
+    // Generate date and time according to the specification.
     quint64 time = ((timeOnly.second() + 1) >> 1) + (timeOnly.minute() << 5) + (timeOnly.hour() << 11);
     quint64 date = dateOnly.day() + (dateOnly.month() << 5) + (dateOnly.year() - 1980);
-    const quint8 tlo = time & 0xff;
-    const quint8 thi = time >> 8;
-    const quint8 dlo = date & 0xff;
-    const quint8 dhi = date >> 8;
-    const quint8 rootDir[] = { 0x4f, 0x56, 0x45, 0x52, 0x4c, 0x41, 0x59, 0x20,
+    quint8 tlo = time & 0xff;
+    quint8 thi = time >> 8;
+    quint8 dlo = date & 0xff;
+    quint8 dhi = date >> 8;
+    // Root directory will not be visible to user and contains stuff like the
+    // fat label again. Apart from that it's like any other extent.
+    quint8 rootDir[] = { 0x4f, 0x56, 0x45, 0x52, 0x4c, 0x41, 0x59, 0x20,
         0x20, 0x20, 0x20, 0x08, 0x00, 0x00, tlo, thi, dlo, dhi, dlo, dhi, 0x00,
         0x00, tlo, thi, dlo, dhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+    // OVERLAY.IMG extent.
+    auto s = [&maxFileSize, &getbyte](int i) {
+        return getbyte(maxFileSize, i);
+    };
+    quint8 fileEntry[] = { 0x4f, 0x56, 0x45, 0x52, 0x4c, 0x41, 0x59, 0x20,
+        0x49, 0x4d, 0x47, 0x20, 0x00, 0x00, tlo, thi, dlo, dhi, dlo, dhi, 0x00,
+        0x00, tlo, thi, dlo, dhi, FIRST_CLUSTER, 0x00, s(0), s(1), s(2), s(3) };
+    // Actually start writing stuff and keep track of progress.
     seekto(offset);
     m_bytesWritten = 0;
-    m_totalBytes = headerSize + maxFileSize;
+    m_totalBytes = headerSize + fileZeros;
 
     writeBytes<decltype(bootSector)>(bootSector);
     writeBytes<decltype(bootCode)>(bootCode);
@@ -238,6 +269,7 @@ void BlockDevice::formatOverlayPartition(quint64 offset, quint64 size) {
 
     writeZeros(SECTOR_SIZE * 4);
 
+    // Backup boot sector because this is intended for flash memory.
     writeBytes<decltype(bootSector)>(bootSector);
     writeBytes<decltype(bootCode)>(bootCode);
     writeZeros(bootCodeSize - std::extent<decltype(bootCode)>::value);
@@ -247,26 +279,23 @@ void BlockDevice::formatOverlayPartition(quint64 offset, quint64 size) {
     std::size_t used = std::extent<decltype(fat)>::value;
     used += (nextFreeCluster - (FIRST_CLUSTER + 1)) * 4;
     used += std::extent<decltype(fatEof)>::value;
+    /**
+     * Write cluster chain which marks which clusters have been used and which
+     * are still available.
+     */
     for (std::size_t i = 0; i < NR_FATS; ++i) {
         writeBytes<decltype(fat)>(fat);
         // Cluster number count starts with one because zero would mark a free cluster.
         for (quint64 cluster = FIRST_CLUSTER + 1; cluster < nextFreeCluster; ++cluster) {
-            const quint32 number = qToLittleEndian(cluster);
+            quint32 number = qToLittleEndian(cluster);
             writeBytes(&number);
         }
         writeBytes<decltype(fatEof)>(fatEof);
         writeZeros(SECTOR_SIZE * fatlength - used);
     }
-
-    auto s = [&maxFileSize, &getbyte](int i) {
-        return getbyte(maxFileSize, i);
-    };
-    const quint8 fileEntry[] = { 0x4f, 0x56, 0x45, 0x52, 0x4c, 0x41, 0x59, 0x20,
-        0x49, 0x4d, 0x47, 0x20, 0x00, 0x00, tlo, thi, dlo, dhi, dlo, dhi, 0x00,
-        0x00, tlo, thi, dlo, dhi, FIRST_CLUSTER, 0x00, s(0), s(1), s(2), s(3) };
-
+    // Write extents.
     writeBytes<decltype(rootDir)>(rootDir);
     writeBytes<decltype(fileEntry)>(fileEntry);
     writeZeros(clusterSize - std::extent<decltype(rootDir)>::value - std::extent<decltype(fileEntry)>::value);
-    writeZeros(64 * 1024);
+    writeZeros(fileZeros);
 }
-- 
2.14.1

