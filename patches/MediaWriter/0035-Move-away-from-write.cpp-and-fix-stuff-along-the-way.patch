From b5debcf2fdd68224529b681ecd7aa43a50bc58ec Mon Sep 17 00:00:00 2001
From: squimrel <squimrel@users.noreply.github.com>
Date: Wed, 23 Aug 2017 15:03:34 +0000
Subject: [PATCH 35/40] Move away from write.cpp and fix stuff along the way

---
 helper/genericdrive.cpp | 156 +++++++++++++++++++++++++++++++++++++++++++++++-
 helper/genericdrive.h   |   3 +
 helper/main.cpp         |  11 +---
 helper/write.cpp        | 154 +----------------------------------------------
 helper/write.h          |  14 +----
 5 files changed, 163 insertions(+), 175 deletions(-)

diff --git a/helper/genericdrive.cpp b/helper/genericdrive.cpp
index 71abf3f..6935ae3 100644
--- a/helper/genericdrive.cpp
+++ b/helper/genericdrive.cpp
@@ -20,28 +20,154 @@
 #include "genericdrive.h"
 
 #include <string>
+#include <stdexcept>
 
 #include <QString>
 #include <QTextStream>
+#include <QFile>
+#include <QFileInfo>
 
+#include <libcheckisomd5.h>
 #include <libimplantisomd5.h>
+#include <lzma.h>
 
 #include "blockdevice.h"
+#include "page_aligned_buffer.h"
 #include "write.h"
 
+#ifndef MEDIAWRITER_LZMA_LIMIT
+// 256MB memory limit for the decompressor
+#define MEDIAWRITER_LZMA_LIMIT (1024 * 1024 * 256)
+#endif
+
+void GenericDrive::writeCompressed(const QString &source) {
+    qint64 totalRead = 0;
+
+    lzma_stream strm = LZMA_STREAM_INIT;
+    lzma_ret ret;
+
+    PageAlignedBuffer<2> buffers;
+    const std::size_t bufferSize = buffers.size;
+    char *inBuffer = static_cast<char *>(buffers.get(0));
+    char *outBuffer = static_cast<char *>(buffers.get(1));
+    auto total = QFileInfo(source).size();
+    ProgressStats progress;
+    progress.fd = getDescriptor();
+
+    QFile file(source);
+    file.open(QIODevice::ReadOnly);
+
+    ret = lzma_stream_decoder(&strm, MEDIAWRITER_LZMA_LIMIT, LZMA_CONCATENATED);
+    if (ret != LZMA_OK) {
+        throw std::runtime_error("Failed to start decompressing.");
+    }
+
+    strm.next_in = reinterpret_cast<uint8_t *>(inBuffer);
+    strm.avail_in = 0;
+    strm.next_out = reinterpret_cast<uint8_t *>(outBuffer);
+    strm.avail_out = bufferSize;
+
+    while (true) {
+        if (strm.avail_in == 0) {
+            qint64 len = file.read(inBuffer, bufferSize);
+            totalRead += len;
+
+            strm.next_in = reinterpret_cast<uint8_t *>(inBuffer);
+            strm.avail_in = len;
+
+            onProgress(&progress, totalRead, total);
+        }
+
+        ret = lzma_code(&strm, strm.avail_in == 0 ? LZMA_FINISH : LZMA_RUN);
+        if (ret == LZMA_STREAM_END) {
+            write(outBuffer, bufferSize - strm.avail_out);
+            return;
+        }
+        if (ret != LZMA_OK) {
+            switch (ret) {
+            case LZMA_MEM_ERROR:
+                throw std::runtime_error("There is not enough memory to decompress the file.");
+                break;
+            case LZMA_FORMAT_ERROR:
+            case LZMA_DATA_ERROR:
+            case LZMA_BUF_ERROR:
+                throw std::runtime_error("The downloaded compressed file is corrupted.");
+                break;
+            case LZMA_OPTIONS_ERROR:
+                throw std::runtime_error("Unsupported compression options.");
+                break;
+            default:
+                throw std::runtime_error("Unknown decompression error.");
+                break;
+            }
+        }
+
+        if (strm.avail_out == 0) {
+            write(outBuffer, bufferSize - strm.avail_out);
+
+            strm.next_out = reinterpret_cast<uint8_t *>(outBuffer);
+            strm.avail_out = bufferSize;
+        }
+    }
+}
+
+void GenericDrive::writePlain(const QString &source) {
+    QFile inFile(source);
+    inFile.open(QIODevice::ReadOnly);
+
+    if (!inFile.isReadable()) {
+        throw std::runtime_error("Source image is not readable");
+    }
+
+    PageAlignedBuffer<2> buffers;
+    const std::size_t bufferSize = buffers.size;
+    char *buffer = static_cast<char *>(buffers.get(0));
+    auto total = QFileInfo(source).size();
+    ProgressStats progress;
+    progress.fd = getDescriptor();
+
+    QTextStream out(stdout);
+    qint64 bytesWritten = 0;
+    while (!inFile.atEnd()) {
+        qint64 len = inFile.read(buffer, bufferSize);
+        if (len < 0) {
+            throw std::runtime_error("Source image is not readable");
+        }
+        write(buffer, len);
+        bytesWritten += len;
+
+        onProgress(&progress, bytesWritten, total);
+    }
+}
+
 void GenericDrive::writeFile(const QString &source) {
     // Immediately trigger the UI into writing mode.
     QTextStream out(stdout);
     out << "1\n";
     out.flush();
     if (source.endsWith(".xz"))
-        ::writeCompressed(source, this);
+        writeCompressed(source);
     else
-        ::writePlain(source, this);
+        writePlain(source);
 }
 
 void GenericDrive::checkChecksum() {
-    ::check(getDescriptor());
+    QTextStream out(stdout);
+    out << "CHECK\n";
+    out.flush();
+
+    ProgressStats progress;
+    switch (mediaCheckFD(getDescriptor(), &onProgress, &progress)) {
+    case ISOMD5SUM_CHECK_NOT_FOUND:
+    case ISOMD5SUM_CHECK_PASSED:
+        out << "OK\n";
+        out.flush();
+        break;
+    case ISOMD5SUM_CHECK_FAILED:
+        throw std::runtime_error("Your drive is probably damaged.");
+    default:
+        throw std::runtime_error("Unexpected error occurred during media check.");
+    }
 }
 
 void GenericDrive::implantChecksum() {
@@ -57,3 +183,27 @@ void GenericDrive::addOverlay(quint64 offset, quint64 size) {
     device.addPartition(offset, size);
     device.formatOverlayPartition(offset, size);
 }
+
+void GenericDrive::writeIso(const QString &source, bool persistentStorage) {
+    auto sourceFile = source.toStdString();
+    if (::changePersistentStorage(sourceFile, persistentStorage)) {
+        char *errstr;
+        if (::implantISOFile(sourceFile.c_str(), false, true, true, &errstr) != 0) {
+            throw std::runtime_error(std::string(errstr));
+        }
+    }
+    umount();
+    writeFile(source);
+    checkChecksum();
+    if (persistentStorage) {
+        umount();
+        QTextStream out(stdout);
+        out << "OVERLAY\n";
+        out.flush();
+        auto size = QFileInfo(source).size();
+        addOverlayPartition(size);
+        implantChecksum();
+        out << "DONE\n";
+        out.flush();
+    }
+}
diff --git a/helper/genericdrive.h b/helper/genericdrive.h
index c9c84c0..147c9bb 100644
--- a/helper/genericdrive.h
+++ b/helper/genericdrive.h
@@ -32,7 +32,10 @@ public:
     virtual void wipe() = 0;
     virtual void addOverlayPartition(quint64 offset) = 0;
     virtual void umount() = 0;
+    void writePlain(const QString &source);
+    void writeCompressed(const QString &source);
     void writeFile(const QString& source);
+    void writeIso(const QString& source, bool persistentStorage);
     void checkChecksum();
     void implantChecksum();
 protected:
diff --git a/helper/main.cpp b/helper/main.cpp
index 892c206..9bd7c59 100644
--- a/helper/main.cpp
+++ b/helper/main.cpp
@@ -27,12 +27,6 @@
 
 // Platform specific drive handler.
 #include "drive.h"
-#include "write.h"
-
-void restore(Drive *const drive) {
-    drive->umount();
-    drive->wipe();
-}
 
 int main(int argc, char *argv[]) {
     const QString action = argv[1];
@@ -57,10 +51,11 @@ int main(int argc, char *argv[]) {
         try {
             drive->init();
             if (isRestore) {
-                restore(drive);
+                drive->umount();
+                drive->wipe();
             }
             else {
-                write(argv[2], drive, persistentStorage);
+                drive->writeIso(argv[2], persistentStorage);
             }
             qApp->exit(0);
         } catch (std::runtime_error &error) {
diff --git a/helper/write.cpp b/helper/write.cpp
index 84ce7d2..32861dd 100644
--- a/helper/write.cpp
+++ b/helper/write.cpp
@@ -20,7 +20,9 @@
 #include "write.h"
 
 #include <cstring>
+#include <unistd.h>
 
+#include <iostream>
 #include <array>
 #include <algorithm>
 #include <fstream>
@@ -31,8 +33,6 @@
 #include <utility>
 #include <vector>
 
-#include <QFile>
-#include <QFileInfo>
 #include <QObject>
 #include <QString>
 #include <QTextStream>
@@ -40,11 +40,6 @@
 #include <QtEndian>
 
 #include <iso9660io.h>
-#include <libcheckisomd5.h>
-#include <libimplantisomd5.h>
-#include <lzma.h>
-
-#include "page_aligned_buffer.h"
 
 constexpr char partitionLabel[] = "OVERLAY";
 constexpr char overlayFilename[] = "OVERLAY.IMG";
@@ -336,7 +331,7 @@ static bool modifyIso(iso9660::Image *const image, const char *const filename, b
     return image->modify_file(*file, removeOverlay);
 }
 
-static bool modifyIso(const std::string &filename, bool persistentStorage) {
+bool changePersistentStorage(const std::string &filename, bool persistentStorage) {
     constexpr const char *const configfiles[] = { "isolinux.cfg", "grub.cfg", "grub.conf" };
     std::fstream isofile(filename, std::ios::binary | std::ios::in | std::ios::out);
     iso9660::Image image(&isofile);
@@ -375,146 +370,3 @@ int onProgress(void *data, long long offset, long long total) {
     }
     return 0;
 }
-
-void writeCompressed(const QString &source, GenericDrive *const drive) {
-    qint64 totalRead = 0;
-
-    lzma_stream strm = LZMA_STREAM_INIT;
-    lzma_ret ret;
-
-    PageAlignedBuffer<2> buffers;
-    const std::size_t bufferSize = buffers.size;
-    char *inBuffer = static_cast<char *>(buffers.get(0));
-    char *outBuffer = static_cast<char *>(buffers.get(1));
-    auto total = QFileInfo(source).size();
-    ProgressStats progress;
-    progress.fd = drive->getDescriptor();
-
-    QFile file(source);
-    file.open(QIODevice::ReadOnly);
-
-    ret = lzma_stream_decoder(&strm, MEDIAWRITER_LZMA_LIMIT, LZMA_CONCATENATED);
-    if (ret != LZMA_OK) {
-        throw std::runtime_error("Failed to start decompressing.");
-    }
-
-    strm.next_in = reinterpret_cast<uint8_t *>(inBuffer);
-    strm.avail_in = 0;
-    strm.next_out = reinterpret_cast<uint8_t *>(outBuffer);
-    strm.avail_out = bufferSize;
-
-    while (true) {
-        if (strm.avail_in == 0) {
-            qint64 len = file.read(inBuffer, bufferSize);
-            totalRead += len;
-
-            strm.next_in = reinterpret_cast<uint8_t *>(inBuffer);
-            strm.avail_in = len;
-
-            onProgress(&progress, totalRead, total);
-        }
-
-        ret = lzma_code(&strm, strm.avail_in == 0 ? LZMA_FINISH : LZMA_RUN);
-        if (ret == LZMA_STREAM_END) {
-            drive->write(outBuffer, bufferSize - strm.avail_out);
-            return;
-        }
-        if (ret != LZMA_OK) {
-            switch (ret) {
-            case LZMA_MEM_ERROR:
-                throw std::runtime_error("There is not enough memory to decompress the file.");
-                break;
-            case LZMA_FORMAT_ERROR:
-            case LZMA_DATA_ERROR:
-            case LZMA_BUF_ERROR:
-                throw std::runtime_error("The downloaded compressed file is corrupted.");
-                break;
-            case LZMA_OPTIONS_ERROR:
-                throw std::runtime_error("Unsupported compression options.");
-                break;
-            default:
-                throw std::runtime_error("Unknown decompression error.");
-                break;
-            }
-        }
-
-        if (strm.avail_out == 0) {
-            drive->write(outBuffer, bufferSize - strm.avail_out);
-
-            strm.next_out = reinterpret_cast<uint8_t *>(outBuffer);
-            strm.avail_out = bufferSize;
-        }
-    }
-}
-
-void writePlain(const QString &source, GenericDrive *const drive) {
-    QFile inFile(source);
-    inFile.open(QIODevice::ReadOnly);
-
-    if (!inFile.isReadable()) {
-        throw std::runtime_error("Source image is not readable");
-    }
-
-    PageAlignedBuffer<2> buffers;
-    const std::size_t bufferSize = buffers.size;
-    char *buffer = static_cast<char *>(buffers.get(0));
-    auto total = QFileInfo(source).size();
-    ProgressStats progress;
-    progress.fd = drive->getDescriptor();
-
-    QTextStream out(stdout);
-    qint64 bytesWritten = 0;
-    while (!inFile.atEnd()) {
-        qint64 len = inFile.read(buffer, bufferSize);
-        if (len < 0) {
-            throw std::runtime_error("Source image is not readable");
-        }
-        drive->write(buffer, len);
-        bytesWritten += len;
-
-        onProgress(&progress, bytesWritten, total);
-    }
-}
-
-void check(int fd) {
-    QTextStream out(stdout);
-    out << "CHECK\n";
-    out.flush();
-
-    long long previous = 0LL;
-    switch (mediaCheckFD(fd, &onProgress, &previous)) {
-    case ISOMD5SUM_CHECK_NOT_FOUND:
-    case ISOMD5SUM_CHECK_PASSED:
-        out << "OK\n";
-        out.flush();
-        break;
-    case ISOMD5SUM_CHECK_FAILED:
-        throw std::runtime_error("Your drive is probably damaged.");
-    default:
-        throw std::runtime_error("Unexpected error occurred during media check.");
-    }
-}
-
-void write(const QString &source, GenericDrive *const drive, bool persistentStorage) {
-    auto sourceFile = source.toStdString();
-    if (modifyIso(sourceFile, persistentStorage)) {
-        char *errstr;
-        if (implantISOFile(sourceFile.c_str(), false, true, true, &errstr) != 0) {
-            throw std::runtime_error(std::string(errstr));
-        }
-    }
-    drive->umount();
-    drive->writeFile(source);
-    drive->checkChecksum();
-    if (persistentStorage) {
-        drive->umount();
-        QTextStream out(stdout);
-        out << "OVERLAY\n";
-        out.flush();
-        auto size = QFileInfo(source).size();
-        drive->addOverlayPartition(size);
-        drive->implantChecksum();
-        out << "DONE\n";
-        out.flush();
-    }
-}
diff --git a/helper/write.h b/helper/write.h
index f5cb6f4..6adbcda 100644
--- a/helper/write.h
+++ b/helper/write.h
@@ -23,14 +23,6 @@
 #include <QString>
 #include <QtGlobal>
 
-// Platform specific drive handler.
-#include "genericdrive.h"
-
-#ifndef MEDIAWRITER_LZMA_LIMIT
-// 256MB memory limit for the decompressor
-#define MEDIAWRITER_LZMA_LIMIT (1024 * 1024 * 256)
-#endif
-
 struct ProgressStats {
     qint64 progress{ 0LL };
     int syncs{ 0 };
@@ -38,10 +30,6 @@ struct ProgressStats {
 };
 
 int onProgress(void *data, long long offset, long long total);
-void check(int fd);
-void writePlain(const QString &source, GenericDrive *const drive);
-void writeCompressed(const QString &source, GenericDrive *const drive);
-
-void write(const QString &source, GenericDrive *const drive, bool persistentStorage = false);
+bool changePersistentStorage(const std::string &filename, bool persistentStorage);
 
 #endif // WRITE_H
-- 
2.14.1

