From 18e3f55b03a7fdec61de88220967129152cd0fed Mon Sep 17 00:00:00 2001
From: squimrel <squimrel@users.noreply.github.com>
Date: Mon, 24 Jul 2017 08:09:51 +0000
Subject: [PATCH 15/40] Provide a cross-platform way to format a partition

---
 helper/linux/drive.cpp |  15 +++---
 helper/partition.cpp   | 137 +++++++++++++++++++++++++++++++++++++++++++++++--
 helper/partition.h     |  21 +++++++-
 3 files changed, 160 insertions(+), 13 deletions(-)

diff --git a/helper/linux/drive.cpp b/helper/linux/drive.cpp
index 6b224a5..eac9101 100644
--- a/helper/linux/drive.cpp
+++ b/helper/linux/drive.cpp
@@ -127,11 +127,18 @@ void Drive::wipe() {
  * filesystem.
  */
 QPair<QString, quint64> Drive::addPartition(quint64 offset, const QString &label) {
+    /**
+     * Currently unused because the label "OVERLAY    " is hardcoded into
+     * formatPartition at the moment.
+     * TODO(squimrel): Fix this.
+     */
+    Q_UNUSED(label);
     open();
     PartitionTable table(getDescriptor());
     table.read();
     const quint64 size = m_device->property("Size").toULongLong() - offset;
     int number = table.addPartition(offset, size);
+    table.formatPartition(offset, size);
     close();
     /*
      * Not using udisks to add partition at the moment because parted detects
@@ -148,14 +155,6 @@ QPair<QString, quint64> Drive::addPartition(quint64 offset, const QString &label
     */
     // Path is not as reliable as the one that would be provided by udisks.
     QString partitionPath = QString("%0%1").arg(m_identifier).arg(number);
-    QProcess process;
-    process.setProgram("mkfs.vfat");
-    process.setArguments(QStringList() << "-n" << label << QString("%0%1").arg(m_device->property("Device").toString()).arg(number));
-    process.start();
-    process.waitForFinished();
-    if (process.exitCode() != 0) {
-        throw std::runtime_error("Couldn't format disk");
-    }
     /*
      * Not using udisks to format at the moment because of the following error:
      * Error synchronizing after initial wipe: Timed out waiting for object
diff --git a/helper/partition.cpp b/helper/partition.cpp
index 6ee9a14..6be3166 100644
--- a/helper/partition.cpp
+++ b/helper/partition.cpp
@@ -27,8 +27,10 @@
 #include <array>
 #include <utility>
 
-#include <QtGlobal>
+#include <QDateTime>
+#include <QtAlgorithms>
 #include <QtEndian>
+#include <QtGlobal>
 
 PartitionTable::PartitionTable(int fd) : m_fd(fd) {
 }
@@ -38,7 +40,7 @@ void PartitionTable::setFileDescriptor(int fd) {
 }
 
 void PartitionTable::read() {
-    seek();
+    seekEntry();
     for (std::size_t i = 0; i < MAX_PARTITIONS; ++i) {
         PartitionEntry entry;
         if (::read(m_fd, entry.data(), entry.size()) != entry.size()) {
@@ -52,12 +54,28 @@ void PartitionTable::read() {
     }
 }
 
-void PartitionTable::seek(std::size_t index) {
+void PartitionTable::seekEntry(std::size_t index) {
     if (::lseek(m_fd, PARTITION_ENTRY_OFFSET + PARTITION_ENTRY_SIZE * index, SEEK_SET) < 0) {
         throw std::runtime_error("Failed to seek to partition table.");
     }
 }
 
+void PartitionTable::seekto(std::size_t position) {
+    if (::lseek(m_fd, position, SEEK_SET) < 0) {
+        throw std::runtime_error("Failed to seek on block device.");
+    }
+}
+
+void PartitionTable::writeZeros(std::size_t size) {
+    constexpr std::size_t CHUNK_SIZE = 512;
+    constexpr char zeros[CHUNK_SIZE]{};
+    for (std::size_t i = 0; i < size; i += CHUNK_SIZE) {
+        if (::write(m_fd, zeros, std::min(CHUNK_SIZE, size - i)) < 0) {
+            throw std::runtime_error("Failed to write zeros to block device.");
+        }
+    }
+}
+
 void PartitionTable::wipeMac() {
     if (m_apmHeader == nullptr) {
         m_apmHeader = std::unique_ptr<std::array<char, APM_SIZE>>(new std::array<char, APM_SIZE>());
@@ -132,7 +150,7 @@ int PartitionTable::addPartition(quint64 offset, quint64 size) {
         throw std::runtime_error("Partition table is full.");
     }
     m_entries.append(std::move(entry));
-    seek(num - 1);
+    seekEntry(num - 1);
     auto bytes = ::write(m_fd, entry.data(), entry.size());
     if (bytes != static_cast<decltype(bytes)>(entry.size())) {
         throw std::runtime_error("Failed to add partition.");
@@ -140,6 +158,117 @@ int PartitionTable::addPartition(quint64 offset, quint64 size) {
     return num;
 }
 
+void PartitionTable::formatPartition(quint64 offset, quint64 size) {
+    constexpr int RESERVED_SECTORS = 32;
+    constexpr int NR_FATS = 2;
+    auto getbyte = [](int number, int i) -> quint8 {
+        return (number >> (8 * i)) & 0xff;
+    };
+    auto align = [](int number, int alignment) -> int {
+        return (number + alignment - 1) & ~(alignment - 1);
+    };
+    auto divCeil = [](int a, int b) -> int {
+        return (a + b - 1) / b;
+    };
+
+    const quint32 volumeId = QDateTime::currentMSecsSinceEpoch() & 0xffffffff;
+    auto u = [&volumeId, &getbyte](int i) {
+        return getbyte(volumeId, i);
+    };
+    /*
+     * Determine the number of sectors per cluster.
+     */
+    quint64 sizeMb = size / (1024 * 1024);
+    const std::array<int, 4> ranges = { 260, 1024 * 8, 1024 * 16, 1024 * 32 };
+    auto found = qLowerBound(ranges.begin(), ranges.end(), sizeMb);
+    quint8 sectorsPerCluster = (found - ranges.begin()) * 8 + 8;
+    if (sectorsPerCluster == 0)
+        sectorsPerCluster = 1;
+
+    const int num_sectors = size / SECTOR_SIZE;
+    /*
+     * FIXME(squimrel): Math from FAT version 1.03 page 21 did not work for me
+     * at all. The math below (from dosfstools) does not give the right result
+     * either though. I'm obviously doing something wrong.
+     */
+    const quint64 fatdata = num_sectors - RESERVED_SECTORS;
+    const int clusters = (fatdata * SECTOR_SIZE + NR_FATS * 8) / (sectorsPerCluster * SECTOR_SIZE + NR_FATS * 4);
+    const int fatlength = align(divCeil((clusters + 2) * 4, SECTOR_SIZE), sectorsPerCluster);
+    /**
+     * Magic values were generated by mkfs.fat (dosfstools).
+     */
+    constexpr quint8 bootSign[] = { 0x55, 0xaa };
+    constexpr quint8 infoSector[] = { 0x52, 0x52, 0x61, 0x61 };
+    constexpr std::size_t fsinfoOffset = 0x1e0;
+    const quint8 fsinfo[] = { 0x00, 0x00, 0x00, 0x00, 0x72, 0x72, 0x41, 0x61,
+        0x8a, 0x7f, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00 };
+    constexpr quint8 fat[] = {
+        0xf8, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0x0f
+    };
+    const auto clsz = sectorsPerCluster;
+    const quint8 bootSector[] = { 0xeb, 0x58, 0x90, 0x6d, 0x6b, 0x66, 0x73,
+        0x2e, 0x66, 0x61, 0x74, 0x00, 0x02, clsz, 0x20, 0x00, 0x02, 0x00, 0x00,
+        0x00, 0x00, 0xf8, 0x00, 0x00, 0x3e, 0x00, 0xf7, 0x00, 0x00, 0x98, 0x2e,
+        0x00, 0x00, 0x28, 0xc0, 0x00, 0xf8, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x29,
+        u(3), u(2), u(1), u(0), 0x4f, 0x56, 0x45, 0x52, 0x4c, 0x41, 0x59, 0x20,
+        0x20, 0x20, 0x20, 0x46, 0x41, 0x54, 0x33, 0x32, 0x20, 0x20, 0x20 };
+    const quint8 bootCode[] = { 0x0e, 0x1f, 0xbe, 0x77, 0x7c, 0xac, 0x22, 0xc0,
+        0x74, 0x0b, 0x56, 0xb4, 0x0e, 0xbb, 0x07, 0x00, 0xcd, 0x10, 0x5e, 0xeb,
+        0xf0, 0x32, 0xe4, 0xcd, 0x16, 0xcd, 0x19, 0xeb, 0xfe, 0x54, 0x68, 0x69,
+        0x73, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x20, 0x62,
+        0x6f, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x64, 0x69, 0x73, 0x6b,
+        0x2e, 0x20, 0x20, 0x50, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x69, 0x6e,
+        0x73, 0x65, 0x72, 0x74, 0x20, 0x61, 0x20, 0x62, 0x6f, 0x6f, 0x74, 0x61,
+        0x62, 0x6c, 0x65, 0x20, 0x66, 0x6c, 0x6f, 0x70, 0x70, 0x79, 0x20, 0x61,
+        0x6e, 0x64, 0x0d, 0x0a, 0x70, 0x72, 0x65, 0x73, 0x73, 0x20, 0x61, 0x6e,
+        0x79, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x72, 0x79,
+        0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x20, 0x2e, 0x2e, 0x2e, 0x20, 0x0d,
+        0x0a };
+    constexpr std::size_t bootCodeSize = 420;
+    const auto datetime = QDateTime::currentDateTimeUtc();
+    const auto timeOnly = datetime.time();
+    const auto dateOnly = datetime.date();
+    quint64 time = ((timeOnly.second() + 1) >> 1) + (timeOnly.minute() << 5) + (timeOnly.hour() << 11);
+    quint64 date = dateOnly.day() + (dateOnly.month() << 5) + (dateOnly.year() - 1980);
+    const quint8 tlo = time & 0xff;
+    const quint8 thi = time >> 8;
+    const quint8 dlo = date & 0xff;
+    const quint8 dhi = date >> 8;
+    const quint8 rootDir[] = { 0x4f, 0x56, 0x45, 0x52, 0x4c, 0x41, 0x59, 0x20,
+        0x20, 0x20, 0x20, 0x08, 0x00, 0x00, tlo, thi, dlo, dhi, dlo, dhi, 0x00,
+        0x00, tlo, thi, dlo, dhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+    seekto(offset);
+
+    writeBytes<decltype(bootSector)>(bootSector);
+    writeBytes<decltype(bootCode)>(bootCode);
+    writeZeros(bootCodeSize - std::extent<decltype(bootCode)>::value);
+    writeBytes<decltype(bootSign)>(bootSign);
+
+    writeBytes<decltype(infoSector)>(infoSector);
+    writeZeros(fsinfoOffset - std::extent<decltype(infoSector)>::value);
+    writeBytes<decltype(fsinfo)>(fsinfo);
+    writeZeros(14);
+    writeBytes<decltype(bootSign)>(bootSign);
+
+    writeZeros(SECTOR_SIZE * 4);
+
+    writeBytes<decltype(bootSector)>(bootSector);
+    writeBytes<decltype(bootCode)>(bootCode);
+    writeZeros(bootCodeSize - std::extent<decltype(bootCode)>::value);
+    writeBytes<decltype(bootSign)>(bootSign);
+
+    writeZeros(SECTOR_SIZE * 25);
+    writeBytes<decltype(fat)>(fat);
+    writeZeros(SECTOR_SIZE - std::extent<decltype(fat)>::value);
+    writeZeros(SECTOR_SIZE * fatlength);
+    writeBytes<decltype(fat)>(fat);
+    writeZeros(SECTOR_SIZE - std::extent<decltype(fat)>::value);
+    writeZeros(SECTOR_SIZE * fatlength);
+    writeBytes<decltype(rootDir)>(rootDir);
+}
+
 quint64 PartitionTable::diskSize() {
     static quint64 size = 0;
     if (size != 0)
diff --git a/helper/partition.h b/helper/partition.h
index bfdeb24..644824c 100644
--- a/helper/partition.h
+++ b/helper/partition.h
@@ -52,13 +52,18 @@ private:
 
     quint64 diskSize();
     void fillChs(char *chs, quint64 position);
-    void seek(std::size_t index = 0);
+    void seekEntry(std::size_t index = 0);
+    void seekto(std::size_t position);
+    template <class T>
+    void writeBytes(const T buffer);
+    void writeZeros(std::size_t size);
 
 public:
     PartitionTable(int fd);
     void setFileDescriptor(int fd);
     void read();
     int addPartition(quint64 offset = 1024ULL * 1024ULL, quint64 size = 0);
+    void formatPartition(quint64 offset, quint64 size);
     void wipeMac();
     void restoreMac();
 
@@ -68,4 +73,18 @@ private:
     std::unique_ptr<std::array<char, APM_SIZE>> m_apmHeader;
 };
 
+/**
+ * Originally the idea of having this template was so that one does not have to
+ * pass in the size.
+ * Poorly when type auto deduction is done type information is lost and the
+ * resulting type is a pointer.
+ * Therefore the user has to explicitly pass in the type.
+ */
+template <class T>
+void PartitionTable::writeBytes(const T buffer) {
+    if (::write(m_fd, buffer, std::extent<T>::value) < 0) {
+        throw std::runtime_error("Failed to write buffer to block device.");
+    }
+}
+
 #endif // PARTITION_H
-- 
2.14.1

