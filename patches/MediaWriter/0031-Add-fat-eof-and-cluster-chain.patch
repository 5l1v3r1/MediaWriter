From 1fbc35978f4572be793a9d81de2ec8fd534ee746 Mon Sep 17 00:00:00 2001
From: squimrel <squimrel@users.noreply.github.com>
Date: Tue, 22 Aug 2017 14:24:03 +0000
Subject: [PATCH 31/40] Add fat eof and cluster chain

Zero out only the first 64kB of the overlay file because that's
what dracut does when it resets the overlay.
---
 helper/blockdevice.cpp  | 61 +++++++++++++++++++++++++++++++++----------------
 helper/blockdevice.h    |  4 +++-
 helper/genericdrive.cpp |  5 ++++
 helper/write.cpp        | 40 +++++++++++++-------------------
 4 files changed, 65 insertions(+), 45 deletions(-)

diff --git a/helper/blockdevice.cpp b/helper/blockdevice.cpp
index f3f902a..944c976 100644
--- a/helper/blockdevice.cpp
+++ b/helper/blockdevice.cpp
@@ -130,12 +130,13 @@ int BlockDevice::addPartition(quint64 offset, quint64 size) {
 void BlockDevice::formatOverlayPartition(quint64 offset, quint64 size) {
     constexpr int RESERVED_SECTORS = 32;
     constexpr int NR_FATS = 2;
+    constexpr quint64 FIRST_CLUSTER = 3;
+    auto align = [](quint64 number, quint64 alignment) -> quint64 {
+        return (number + alignment - 1) & ~(alignment - 1);
+    };
     auto getbyte = [](int number, int i) -> quint8 {
         return (number >> (8 * i)) & 0xff;
     };
-    auto align = [](int number, int alignment) -> int {
-        return (number + alignment - 1) & ~(alignment - 1);
-    };
     auto divCeil = [](int a, int b) -> int {
         return (a + b - 1) / b;
     };
@@ -144,22 +145,37 @@ void BlockDevice::formatOverlayPartition(quint64 offset, quint64 size) {
     const std::array<int, 4> ranges = { { 260, 1024 * 8, 1024 * 16, 1024 * 32 } };
     auto found = qLowerBound(ranges.begin(), ranges.end(), sizeMb);
     const int sectorsPerCluster = found == ranges.begin() ? 1 : (found - ranges.begin()) * 8;
+    const int clusterSize = SECTOR_SIZE * sectorsPerCluster;
     const int numSectors = size / SECTOR_SIZE;
     const quint64 fatdata = numSectors - RESERVED_SECTORS;
-    const int clusters = (fatdata * SECTOR_SIZE + NR_FATS * 8) / (sectorsPerCluster * SECTOR_SIZE + NR_FATS * 4);
-    const int fatlength = align(divCeil((clusters + 2) * 4, SECTOR_SIZE), sectorsPerCluster);
+    const quint64 clusters = (fatdata * SECTOR_SIZE + NR_FATS * 8) / (sectorsPerCluster * SECTOR_SIZE + NR_FATS * 4);
+    const quint64 fatlength = align(divCeil((clusters + 2) * 4, SECTOR_SIZE), sectorsPerCluster);
+    const quint64 headerSize = (RESERVED_SECTORS + fatlength * 2 + sectorsPerCluster) * SECTOR_SIZE;
+    quint64 maxFileSize = std::min(size - headerSize, 0xffffffffULL);
+    maxFileSize = align(maxFileSize - SECTOR_SIZE - 1, SECTOR_SIZE);
+    const quint64 nextFreeCluster = FIRST_CLUSTER + (maxFileSize / clusterSize) + 1;
+    const quint64 numFreeClusters = ((size - headerSize) / clusterSize) + 1;
     /**
      * Magic values were generated by mkfs.fat (dosfstools).
      */
     constexpr quint8 bootSign[] = { 0x55, 0xaa };
     constexpr quint8 infoSector[] = { 0x52, 0x52, 0x61, 0x41 };
     constexpr std::size_t fsinfoOffset = 480;
-    const quint8 fsinfo[] = { 0x72, 0x72, 0x41, 0x61, 0x8a, 0x7f, 0x03, 0x00,
-        0x02, 0x00, 0x00, 0x00 };
+    auto fc = [&numFreeClusters, &getbyte](int i) {
+        return getbyte(numFreeClusters, i);
+    };
+    auto nc = [&nextFreeCluster, &getbyte](int i) {
+        return getbyte(nextFreeCluster, i);
+    };
+    const quint8 fsinfo[] = {
+        0x72, 0x72, 0x41, 0x61,
+        fc(0), fc(1), fc(2), fc(3),
+        nc(0), nc(1), nc(2), nc(3)
+    };
     constexpr quint8 fat[] = {
-        0xf8, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0x0f,
-        0xff, 0xff, 0xff, 0x0f
+        0xf8, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0x0f
     };
+    constexpr quint8 fatEof[] = { 0xff, 0xff, 0xff, 0x0f };
     auto t = [&numSectors, &getbyte](int i) {
         return getbyte(numSectors, i);
     };
@@ -205,8 +221,6 @@ void BlockDevice::formatOverlayPartition(quint64 offset, quint64 size) {
         0x20, 0x20, 0x20, 0x08, 0x00, 0x00, tlo, thi, dlo, dhi, dlo, dhi, 0x00,
         0x00, tlo, thi, dlo, dhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
     seekto(offset);
-    quint64 headerSize = (RESERVED_SECTORS + fatlength * 2 + sectorsPerCluster) * SECTOR_SIZE;
-    quint64 maxFileSize = std::min(size - headerSize, 0xffffffffULL);
     m_bytesWritten = 0;
     m_totalBytes = headerSize + maxFileSize;
 
@@ -229,22 +243,29 @@ void BlockDevice::formatOverlayPartition(quint64 offset, quint64 size) {
     writeBytes<decltype(bootSign)>(bootSign);
 
     writeZeros(SECTOR_SIZE * 25);
-    writeBytes<decltype(fat)>(fat);
-    writeZeros(SECTOR_SIZE - std::extent<decltype(fat)>::value);
-    writeZeros(SECTOR_SIZE * (fatlength - 1));
-    writeBytes<decltype(fat)>(fat);
-    writeZeros(SECTOR_SIZE - std::extent<decltype(fat)>::value);
-    writeZeros(SECTOR_SIZE * (fatlength - 1));
+    std::size_t used = std::extent<decltype(fat)>::value;
+    used += (nextFreeCluster - (FIRST_CLUSTER + 1)) * 4;
+    used += std::extent<decltype(fatEof)>::value;
+    for (std::size_t i = 0; i < NR_FATS; ++i) {
+        writeBytes<decltype(fat)>(fat);
+        // Cluster number count starts with one because zero would mark a free cluster.
+        for (quint64 cluster = FIRST_CLUSTER + 1; cluster < nextFreeCluster; ++cluster) {
+            const quint32 number = qToLittleEndian(cluster);
+            writeBytes(&number);
+        }
+        writeBytes<decltype(fatEof)>(fatEof);
+        writeZeros(SECTOR_SIZE * fatlength - used);
+    }
 
     auto s = [&maxFileSize, &getbyte](int i) {
         return getbyte(maxFileSize, i);
     };
     const quint8 fileEntry[] = { 0x4f, 0x56, 0x45, 0x52, 0x4c, 0x41, 0x59, 0x20,
         0x49, 0x4d, 0x47, 0x20, 0x00, 0x00, tlo, thi, dlo, dhi, dlo, dhi, 0x00,
-        0x00, tlo, thi, dlo, dhi, 0x03, 0x00, s(0), s(1), s(2), s(3) };
+        0x00, tlo, thi, dlo, dhi, FIRST_CLUSTER, 0x00, s(0), s(1), s(2), s(3) };
 
     writeBytes<decltype(rootDir)>(rootDir);
     writeBytes<decltype(fileEntry)>(fileEntry);
-    writeZeros(SECTOR_SIZE * sectorsPerCluster - std::extent<decltype(rootDir)>::value - std::extent<decltype(fileEntry)>::value);
-    writeZeros(maxFileSize);
+    writeZeros(clusterSize - std::extent<decltype(rootDir)>::value - std::extent<decltype(fileEntry)>::value);
+    writeZeros(64 * 1024);
 }
diff --git a/helper/blockdevice.h b/helper/blockdevice.h
index b3113d2..863387a 100644
--- a/helper/blockdevice.h
+++ b/helper/blockdevice.h
@@ -28,6 +28,7 @@
 
 #include <array>
 #include <memory>
+#include <type_traits>
 #include <utility>
 
 #include <QString>
@@ -84,7 +85,8 @@ private:
  */
 template <class T>
 void BlockDevice::writeBytes(const T buffer) {
-    const auto len = ::write(m_fd, buffer, std::extent<T>::value);
+    const auto bytes = std::is_array<T>::value ? std::extent<T>::value : sizeof(typename std::remove_pointer<T>::type);
+    const auto len = ::write(m_fd, buffer, bytes);
     if (len < 0) {
         throw std::runtime_error("Failed to write buffer to block device.");
     }
diff --git a/helper/genericdrive.cpp b/helper/genericdrive.cpp
index 6e1e586..71abf3f 100644
--- a/helper/genericdrive.cpp
+++ b/helper/genericdrive.cpp
@@ -22,6 +22,7 @@
 #include <string>
 
 #include <QString>
+#include <QTextStream>
 
 #include <libimplantisomd5.h>
 
@@ -29,6 +30,10 @@
 #include "write.h"
 
 void GenericDrive::writeFile(const QString &source) {
+    // Immediately trigger the UI into writing mode.
+    QTextStream out(stdout);
+    out << "1\n";
+    out.flush();
     if (source.endsWith(".xz"))
         ::writeCompressed(source, this);
     else
diff --git a/helper/write.cpp b/helper/write.cpp
index fbaaee9..e3d3183 100644
--- a/helper/write.cpp
+++ b/helper/write.cpp
@@ -304,33 +304,32 @@ static std::streamsize manipulateHfsImage(std::fstream *iofile, const iso9660::F
         }
     }
     return 0;
-#endif  // Q_OS_WIN
+#endif // Q_OS_WIN
 }
 
-static bool modifyFatImage(iso9660::Image *const image, const char *const filename, bool persistentStorage) {
+static void modifyFatImage(iso9660::Image *const image, const char *const filename, bool persistentStorage) {
     using namespace std::placeholders;
     auto file = image->find(filename);
-    if (file == nullptr) {
-        return false;
-    }
-    return image->modify_file(*file, std::bind(manipulateFatImage, _1, _2, persistentStorage));
+    if (file == nullptr)
+        return;
+
+    image->modify_file(*file, std::bind(manipulateFatImage, _1, _2, persistentStorage));
 }
 
-static bool modifyHfsImage(iso9660::Image *const image, const char *const filename, bool persistentStorage) {
+static void modifyHfsImage(iso9660::Image *const image, const char *const filename, bool persistentStorage) {
     using namespace std::placeholders;
     auto file = image->find(filename);
-    if (file == nullptr) {
-        return false;
-    }
-    return image->modify_file(*file, std::bind(manipulateHfsImage, _1, _2, persistentStorage));
-    return false;
+    if (file == nullptr)
+        return;
+
+    image->modify_file(*file, std::bind(manipulateHfsImage, _1, _2, persistentStorage));
 }
 
 static bool modifyIso(iso9660::Image *const image, const char *const filename, bool persistentStorage) {
     auto file = image->find(filename);
-    if (file == nullptr) {
+    if (file == nullptr)
         return false;
-    }
+
     if (persistentStorage) {
         return image->modify_file(*file, addOverlay);
     }
@@ -348,12 +347,8 @@ static bool modifyIso(const std::string &filename, bool persistentStorage) {
             changed = true;
         }
     }
-    if (modifyFatImage(&image, "efiboot.img", persistentStorage)) {
-        changed = true;
-    }
-    if (modifyHfsImage(&image, "macboot.img", persistentStorage)) {
-        changed = true;
-    }
+    modifyFatImage(&image, "efiboot.img", persistentStorage);
+    modifyHfsImage(&image, "macboot.img", persistentStorage);
     image.write();
     return changed;
 }
@@ -491,10 +486,6 @@ void check(int fd) {
 }
 
 void write(const QString &source, GenericDrive *const drive, bool persistentStorage) {
-    // Immediately trigger the UI into writing mode.
-    QTextStream out(stdout);
-    out << "1\n";
-    out.flush();
     auto sourceFile = source.toStdString();
     if (modifyIso(sourceFile, persistentStorage)) {
         char *errstr;
@@ -507,6 +498,7 @@ void write(const QString &source, GenericDrive *const drive, bool persistentStor
     drive->checkChecksum();
     if (persistentStorage) {
         drive->umount();
+        QTextStream out(stdout);
         out << "OVERLAY\n";
         out.flush();
         auto size = QFileInfo(source).size();
-- 
2.14.1

