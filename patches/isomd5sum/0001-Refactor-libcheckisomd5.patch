From 367fb48224fe709bc19fa2fe43f88006e1927474 Mon Sep 17 00:00:00 2001
From: squimrel <squimrel@users.noreply.github.com>
Date: Tue, 16 May 2017 10:40:02 +0000
Subject: [PATCH 01/21] Refactor libcheckisomd5

* Use of page-aligned buffer.
* Advertise c11 to the compiler.
* Move common dependencies of libcheckisomd5 and libimplantisomd5 to
shared utilities header.
* Avoid using magic values.
* Declare right before use and trust the compiler with optimizations.
* Make more use of size_t and use off_t where 64 bit me needed.
* Try to make it more compatible with Windows.
* Simplify code to clean appdata.
* Move important define into utilities.
---
 Makefile         |   4 +-
 checkisomd5.c    |   4 +-
 libcheckisomd5.c | 369 ++++++++++++-------------------------------------------
 libcheckisomd5.h |  20 +--
 pyisomd5sum.c    |   3 +-
 utilities.h      |  79 ++++++++++++
 6 files changed, 173 insertions(+), 306 deletions(-)
 create mode 100644 utilities.h

diff --git a/Makefile b/Makefile
index b70d1f1..c2bdbfb 100644
--- a/Makefile
+++ b/Makefile
@@ -10,7 +10,7 @@ else
 LIBDIR = lib
 endif
 
-CFLAGS += -Wall -Werror -D_GNU_SOURCE=1 -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE=1 -D_LARGEFILE64_SOURCE=1 -fPIC $(PYTHONINCLUDE)
+CFLAGS += -std=gnu11 -Wall -Werror -D_GNU_SOURCE=1 -fPIC $(PYTHONINCLUDE)
 
 OBJECTS = md5.o libimplantisomd5.o checkisomd5.o implantisomd5
 SOURCES = $(patsubst %.o,%.c,$(OBJECTS))
@@ -21,7 +21,7 @@ PYOBJS = pyisomd5sum.o libcheckisomd5.a libimplantisomd5.a
 all: implantisomd5 checkisomd5 pyisomd5sum.so libimplantisomd5.a libcheckisomd5.a
 
 %.o: %.c
-	$(CC) $(CPPFLAGS) $(CFLAGS) -c -O -o $@ $<
+	$(CC) $(CPPFLAGS) $(CFLAGS) -c -O3 -o $@ $<
 
 implantisomd5: implantisomd5.o libimplantisomd5.a
 	$(CC) $(CPPFLAGS) $(CFLAGS) implantisomd5.o libimplantisomd5.a -lpopt $(LDFLAGS) -o implantisomd5
diff --git a/checkisomd5.c b/checkisomd5.c
index d08c009..17c13b8 100644
--- a/checkisomd5.c
+++ b/checkisomd5.c
@@ -52,8 +52,8 @@ int user_bailing_out() {
   return retval;
 }
 
-static int outputCB(void *co, long long offset, long long total) {
-    struct progressCBData *data = co;
+static int outputCB(void *const co, const off_t offset, const off_t total) {
+    struct progressCBData *const data = co;
     int gaugeval = -1;
 
     if (data->verbose) {
diff --git a/libcheckisomd5.c b/libcheckisomd5.c
index 79cccac..3aa0b68 100644
--- a/libcheckisomd5.c
+++ b/libcheckisomd5.c
@@ -21,7 +21,6 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
 
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/types.h>
@@ -32,336 +31,120 @@
 
 #include "md5.h"
 #include "libcheckisomd5.h"
-
-#define APPDATA_OFFSET 883
-#define SIZE_OFFSET 84
-
-/* Length in characters of string used for fragment md5sum checking */
-#define FRAGMENT_SUM_LENGTH 60
-
-#define MAX(x, y)  ((x > y) ? x : y)
-#define MIN(x, y)  ((x < y) ? x : y)
-
-/* finds primary volume descriptor and returns info from it */
-/* mediasum must be a preallocated buffer at least 33 bytes long */
-/* fragmentsums must be a preallocated buffer at least FRAGMENT_SUM_LENGTH+1 bytes long */
-static int parsepvd(int isofd, char *mediasum, int *skipsectors, long long *isosize, int *supported, char *fragmentsums, long long *fragmentcount) {
-    unsigned char buf[2048];
-    char buf2[512];
-    char tmpbuf[512];
-    int skipfnd, md5fnd, supportedfnd, fragsumfnd, fragcntfnd;
-    unsigned int loc;
-    long long offset;
-    char *p;
-
-    if (lseek(isofd, (off_t)(16L * 2048L), SEEK_SET) == -1)
-        return ((long long)-1);
-
-    offset = (16L * 2048L);
-    for (;1;) {
-        if (read(isofd, buf, 2048) <= 0)
-            return ((long long)-1);
-
-        if (buf[0] == 1)
-            /* found primary volume descriptor */
-            break;
-        else if (buf[0] == 255)
-            /* hit end and didn't find primary volume descriptor */
-            return ((long long)-1);
-        offset += 2048L;
-    }
-
-    /* read out md5sum */
-    memcpy(buf2, buf + APPDATA_OFFSET, 512);
-    buf2[511] = '\0';
-
-    *supported = 0;
-
-    md5fnd = 0;
-    skipfnd = 0;
-    fragsumfnd = 0;
-    fragcntfnd = 0;
-    supportedfnd = 0;
-    loc = 0;
-    while (loc < 512) {
-        if (!strncmp(buf2 + loc, "ISO MD5SUM = ", 13)) {
-
-            /* make sure we dont walk off end */
-            if ((loc + 32 + 13) > 511)
-                return -1;
-
-            memcpy(mediasum, buf2 + loc + 13, 32);
-            mediasum[32] = '\0';
-            md5fnd = 1;
-            loc += 45;
-            for (p=buf2+loc; loc < 512 && *p != ';'; p++, loc++);
-        } else if (!strncmp(buf2 + loc, "SKIPSECTORS = ", 14)) {
-            char *errptr;
-
-            /* make sure we dont walk off end */
-            if ((loc + 14) > 511)
-                return -1;
-
-            loc = loc + 14;
-            for (p=tmpbuf; loc < 512 && buf2[loc] != ';'; p++, loc++)
-                *p = buf2[loc];
-
-            *p = '\0';
-
-            *skipsectors = strtol(tmpbuf, &errptr, 10);
-            if (errptr && *errptr) {
-                return -1;
-            } else {
-                skipfnd = 1;
-            }
-
-            for (p=buf2+loc; loc < 512 && *p != ';'; p++, loc++);
-        } else if (!strncmp(buf2 + loc, "RHLISOSTATUS=1", 14)) {
-            *supported = 1;
-            supportedfnd = 1;
-            for (p=buf2+loc; loc < 512 && *p != ';'; p++, loc++);
-        } else if (!strncmp(buf2 + loc, "RHLISOSTATUS=0", 14)) {
-            *supported = 0;
-            supportedfnd = 1;
-            for (p=buf2+loc; loc < 512 && *p != ';'; p++, loc++);
-        } else if (!strncmp(buf2 + loc, "FRAGMENT SUMS = ", 16)) {
-            /* make sure we dont walk off end */
-            if ((loc + FRAGMENT_SUM_LENGTH) > 511)
-                return -1;
-
-            memcpy(fragmentsums, buf2 + loc + 16, FRAGMENT_SUM_LENGTH);
-            fragmentsums[FRAGMENT_SUM_LENGTH] = '\0';
-            fragsumfnd = 1;
-            loc += FRAGMENT_SUM_LENGTH + 16;
-            for (p=buf2+loc; loc < 512 && *p != ';'; p++, loc++);
-        } else if (!strncmp(buf2 + loc, "FRAGMENT COUNT = ", 17)) {
-            char *errptr;
-            /* make sure we dont walk off end */
-            if ((loc + 17) > 511)
-                return -1;
-
-            loc = loc + 17;
-            for (p=tmpbuf; loc < 512 && buf2[loc] != ';'; p++, loc++)
-                *p = buf2[loc];
-
-            *p = '\0';
-
-            *fragmentcount = strtol(tmpbuf, &errptr, 10);
-            if (errptr && *errptr) {
-                return -1;
-            } else {
-                fragcntfnd = 1;
-            }
-
-            for (p=buf2+loc; loc < 512 && *p != ';'; p++, loc++);
-        } else {
-            loc++;
-        }
-
-        if ((skipfnd & md5fnd & fragsumfnd & fragcntfnd) & supportedfnd)
-            break;
+#include "utilities.h"
+
+static void clear_appdata(unsigned char *const buffer, const size_t size, const off_t appdata_offset, const off_t offset) {
+    static const ssize_t buffer_start = 0;
+    const ssize_t difference = appdata_offset - offset;
+    if (-APPDATA_SIZE <= difference && difference <= (ssize_t) size) {
+        const size_t clear_start = (size_t) MAX(buffer_start, difference);
+        const size_t clear_len = MIN(size, (size_t)(difference + APPDATA_SIZE)) - clear_start;
+        memset(buffer + clear_start, ' ', clear_len);
     }
-
-    if (!(skipfnd & md5fnd))
-        return -1;
-
-    /* get isosize */
-    *isosize = (buf[SIZE_OFFSET]*0x1000000+buf[SIZE_OFFSET+1]*0x10000 +
-                buf[SIZE_OFFSET+2]*0x100 + buf[SIZE_OFFSET+3]) * 2048LL;
-
-    return offset;
 }
 
-/* mediasum is the sum encoded in media, computedsum is one we compute   */
-/* both strings must be pre-allocated at least 33 chars in length        */
-static int checkmd5sum(int isofd, char *mediasum, char *computedsum, checkCallback cb, void *cbdata) {
-    int nread;
-    int i, j;
-    int appdata_start_offset, appdata_end_offset;
-    int nattempt;
-    int skipsectors;
-    int supported;
-    int current_fragment = 0;
-    int previous_fragment = 0;
-    unsigned int bufsize = 32768;
-    unsigned char md5sum[16];
-    unsigned char fragmd5sum[16];
-    unsigned int len;
-    unsigned char *buf;
-    long long isosize, offset, pvd_offset, apoff;
-    char fragmentsums[FRAGMENT_SUM_LENGTH+1];
-    char thisfragsum[FRAGMENT_SUM_LENGTH+1];
-    long long fragmentcount = 0;
-    MD5_CTX md5ctx, fragmd5ctx;
-
-    if ((pvd_offset = parsepvd(isofd, mediasum, &skipsectors, &isosize, &supported, fragmentsums, &fragmentcount)) < 0)
+static enum isomd5sum_status checkmd5sum(int isofd, checkCallback cb, void *cbdata) {
+    struct volume_info *const info = parsepvd(isofd);
+    if (info == NULL)
         return ISOMD5SUM_CHECK_NOT_FOUND;
 
-    /*    printf("Mediasum = %s\n",mediasum); */
-
-    /* rewind, compute md5sum */
-    lseek(isofd, 0L, SEEK_SET);
-
-    MD5_Init(&md5ctx);
+    const off_t total_size = info->isosize - info->skipsectors * SECTOR_SIZE;
+    if (cb)
+        cb(cbdata, 0, total_size);
 
-    offset = 0;
-    apoff = pvd_offset + APPDATA_OFFSET;
+    /* Rewind, compute md5sum. */
+    lseek(isofd, 0LL, SEEK_SET);
 
-    buf = malloc(bufsize * sizeof(unsigned char));
-    if (cb)
-        cb(cbdata, 0, isosize - skipsectors*2048);
+    MD5_CTX hashctx;
+    MD5_Init(&hashctx);
 
-    while (offset < isosize - skipsectors*2048) {
-        nattempt = MIN(isosize - skipsectors*2048 - offset, bufsize);
+    const size_t buffer_size = NUM_SYSTEM_SECTORS * SECTOR_SIZE;
+    unsigned char *buffer;
+    buffer = aligned_alloc((size_t) getpagesize(), buffer_size * sizeof(*buffer));
 
-        /*      printf("%lld %lld %lld %d\n", offset, isosize, isosize-SKIPSECTORS*2048, nattempt); */
+    size_t previous_fragment = 0UL;
+    off_t offset = 0LL;
+    while (offset < total_size) {
+        const size_t nbyte = MIN((size_t)(total_size - offset), buffer_size);
 
-        nread = read(isofd, buf, nattempt);
-        if (nread <= 0)
+        ssize_t nread = read(isofd, buffer, nbyte);
+        if (nread <= 0L)
             break;
 
-        if (nread > nattempt) {
-            nread = nattempt;
-            lseek(isofd, offset+nread, SEEK_SET);
-        }
-        /* overwrite md5sum we implanted with original data */
-        if (offset < apoff && offset+nread >= apoff) {
-            appdata_start_offset = apoff - offset;
-            appdata_end_offset = MIN(appdata_start_offset+MIN(nread, 512),
-                                     offset + nread - apoff);
-            len = appdata_end_offset - appdata_start_offset;
-            memset(buf+appdata_start_offset, ' ', len);
-        } else if (offset >= apoff && offset+nread < apoff + 512) {
-            appdata_start_offset = 0;
-            appdata_end_offset = nread;
-            len = appdata_end_offset - appdata_start_offset;
-            memset(buf+appdata_start_offset, ' ', len);
-        } else if (offset < apoff + 512 && offset+nread >= apoff + 512) {
-            appdata_start_offset = 0;
-            appdata_end_offset = apoff + 512 - offset;
-            len = appdata_end_offset - appdata_start_offset;
-            memset(buf+appdata_start_offset, ' ', len);
+        /**
+         * Originally was added in 2005 because the kernel was returning the
+         * size from where it started up to the end of the block it pre-fetched
+         * from a cd drive.
+         */
+        if (nread > nbyte) {
+            nread = nbyte;
+            lseek(isofd, offset + nread, SEEK_SET);
         }
-
-        MD5_Update(&md5ctx, buf, nread);
-        if (fragmentcount) {
-            current_fragment = offset * (fragmentcount+1) / (isosize - skipsectors*2048);
-            /* if we're onto the next fragment, calculate the previous sum and check */
-            if ( current_fragment != previous_fragment ) {
-                memcpy(&fragmd5ctx, &md5ctx, sizeof(MD5_CTX));
-                MD5_Final(fragmd5sum, &fragmd5ctx);
-                *computedsum = '\0';
-                j = (current_fragment-1)*FRAGMENT_SUM_LENGTH/fragmentcount;
-                for (i=0; i<FRAGMENT_SUM_LENGTH/fragmentcount; i++) {
-                    char tmpstr[2];
-                    snprintf(tmpstr, 2, "%01x", fragmd5sum[i]);
-                    strncat(computedsum, tmpstr, 2);
-                    thisfragsum[i] = fragmentsums[j++];
-                }
-                thisfragsum[j] = '\0';
-                previous_fragment = current_fragment;
-                /* Exit immediately if current fragment sum is incorrect */
-                if (strcmp(thisfragsum, computedsum) != 0) {
+        /* Make sure appdata which contains the md5sum is cleared. */
+        clear_appdata(buffer, nread, info->offset + APPDATA_OFFSET, offset);
+
+        MD5_Update(&hashctx, buffer, (unsigned int) nread);
+        if (info->fragmentcount) {
+            const size_t current_fragment = (size_t)(offset * (off_t)(info->fragmentcount + 1) / total_size);
+            const size_t fragmentsize = FRAGMENT_SUM_SIZE / info->fragmentcount;
+            /* If we're onto the next fragment, calculate the previous sum and check. */
+            if (current_fragment != previous_fragment) {
+                if (!validate_fragment(&hashctx, current_fragment, fragmentsize,
+                                       info->fragmentsums, NULL)) {
+                    /* Exit immediately if current fragment sum is incorrect */
+                    free(info);
+                    free(buffer);
                     return ISOMD5SUM_CHECK_FAILED;
                 }
+                previous_fragment = current_fragment;
             }
         }
-        offset = offset + nread;
+        offset += nread;
         if (cb)
-          if(cb(cbdata, offset, isosize - skipsectors*2048)) return ISOMD5SUM_CHECK_ABORTED;
+            if (cb(cbdata, offset, total_size)) {
+                free(info);
+                free(buffer);
+                return ISOMD5SUM_CHECK_ABORTED;
+            }
     }
+    free(buffer);
 
     if (cb)
-        cb(cbdata, isosize, isosize - skipsectors*2048);
-
-    sleep(1);
+        cb(cbdata, info->isosize, total_size);
 
-    free(buf);
+    char hashsum[HASH_SIZE + 1];
+    md5sum(hashsum, &hashctx);
 
-    MD5_Final(md5sum, &md5ctx);
-
-    *computedsum = '\0';
-    for (i=0; i<16; i++) {
-        char tmpstr[4];
-        snprintf (tmpstr, 4, "%02x", md5sum[i]);
-        strncat(computedsum, tmpstr, 2);
-    }
-
-    /*    printf("mediasum, computedsum = %s %s\n", mediasum, computedsum); */
-
-    if (strcmp(mediasum, computedsum))
-        return ISOMD5SUM_CHECK_FAILED;
-    else
-        return ISOMD5SUM_CHECK_PASSED;
-}
-
-
-static int doMediaCheck(int isofd, char *mediasum, char *computedsum, long long *isosize, int *supported, checkCallback cb, void *cbdata) {
-    int rc;
-    int skipsectors;
-    long long fragmentcount = 0;
-    char fragmentsums[FRAGMENT_SUM_LENGTH+1];
-
-    if (parsepvd(isofd, mediasum, &skipsectors, isosize, supported, fragmentsums, &fragmentcount) < 0) {
-        return ISOMD5SUM_CHECK_NOT_FOUND;
-    }
-
-    rc = checkmd5sum(isofd, mediasum, computedsum, cb, cbdata);
-
-    return rc;
+    int failed = strcmp(info->hashsum, hashsum);
+    free(info);
+    return failed ? ISOMD5SUM_CHECK_FAILED : ISOMD5SUM_CHECK_PASSED;
 }
 
 int mediaCheckFile(char *file, checkCallback cb, void *cbdata) {
-    int isofd;
-    int rc;
-    char mediasum[33], computedsum[33];
-    long long isosize;
-    int supported;
-
-    isofd = open(file, O_RDONLY);
-
+    int isofd = open(file, O_RDONLY | O_BINARY);
     if (isofd < 0) {
         return ISOMD5SUM_FILE_NOT_FOUND;
     }
-
-    rc = doMediaCheck(isofd, mediasum, computedsum, &isosize, &supported, cb, cbdata);
-
-    close(isofd);
-
-    /*    printf("isosize = %lld\n", isosize); 
-     *    printf("%s\n%s\n", mediasum, computedsum);
-     */
-
-    return rc;
+    return checkmd5sum(isofd, cb, cbdata);
 }
 
 int printMD5SUM(char *file) {
-    int isofd;
-    char mediasum[64];
-    long long isosize;
-    char fragmentsums[FRAGMENT_SUM_LENGTH+1];
-    long long fragmentcount = 0;
-    int supported;
-    int skipsectors;
-
-    isofd = open(file, O_RDONLY);
-
+    int isofd = open(file, O_RDONLY | O_BINARY);
     if (isofd < 0) {
         return ISOMD5SUM_FILE_NOT_FOUND;
     }
-
-    if (parsepvd(isofd, mediasum, &skipsectors, &isosize, &supported, fragmentsums, &fragmentcount) < 0) {
+    struct volume_info *const info = parsepvd(isofd);
+    close(isofd);
+    if (info == NULL) {
         return ISOMD5SUM_CHECK_NOT_FOUND;
     }
 
-    close(isofd);
-
-    printf("%s:   %s\n", file, mediasum);
-    if ( (strlen(fragmentsums) > 0) && (fragmentcount > 0) ) {
-        printf("Fragment sums: %s\n", fragmentsums);
-        printf("Fragment count: %lld\n", fragmentcount); 
-        printf("Supported ISO: %s\n", supported ? "yes" : "no");
+    printf("%s:   %s\n", file, info->hashsum);
+    if (strlen(info->fragmentsums) > 0 && info->fragmentcount > 0) {
+        printf("Fragment sums: %s\n", info->fragmentsums);
+        printf("Fragment count: %ld\n", info->fragmentcount);
+        printf("Supported ISO: %s\n", info->supported ? "yes" : "no");
     }
-
+    free(info);
     return 0;
 }
diff --git a/libcheckisomd5.h b/libcheckisomd5.h
index 78213d1..961d4c7 100644
--- a/libcheckisomd5.h
+++ b/libcheckisomd5.h
@@ -1,14 +1,18 @@
 #ifndef __LIBCHECKISOMD5_H__
-#define  __LIBCHECKISOMD5_H__
+#define __LIBCHECKISOMD5_H__
 
-#define ISOMD5SUM_CHECK_PASSED          1
-#define ISOMD5SUM_CHECK_FAILED          0
-#define ISOMD5SUM_CHECK_ABORTED         2
-#define ISOMD5SUM_CHECK_NOT_FOUND       -1
-#define ISOMD5SUM_FILE_NOT_FOUND        -2
+#include <sys/types.h>
 
-/* for non-zero return value, check is aborted */
-typedef int (*checkCallback)(void *, long long offset, long long total);
+enum isomd5sum_status {
+    ISOMD5SUM_FILE_NOT_FOUND = -2,
+    ISOMD5SUM_CHECK_NOT_FOUND = -1,
+    ISOMD5SUM_CHECK_FAILED = 0,
+    ISOMD5SUM_CHECK_PASSED = 1,
+    ISOMD5SUM_CHECK_ABORTED = 2
+};
+
+/* For non-zero return value, check is aborted. */
+typedef int (*checkCallback)(void *, off_t offset, off_t total);
 
 int mediaCheckFile(char *iso, checkCallback cb, void *cbdata);
 int printMD5SUM(char *file);
diff --git a/pyisomd5sum.c b/pyisomd5sum.c
index 9759950..1425472 100644
--- a/pyisomd5sum.c
+++ b/pyisomd5sum.c
@@ -18,6 +18,7 @@
 
 #include <Python.h>
 #include <stdio.h>
+#include <sys/types.h>
 
 #include "libcheckisomd5.h"
 #include "libimplantisomd5.h"
@@ -34,7 +35,7 @@ static PyMethodDef isomd5sumMethods[] = {
 /* Call python object with offset and total
  * If the object returns true return 1 to abort the check
  */
-int pythonCB(void *cbdata, long long offset, long long total) {
+int pythonCB(void *cbdata, off_t offset, off_t total) {
     PyObject *arglist, *result;
     int rc;
 
diff --git a/utilities.h b/utilities.h
new file mode 100644
index 0000000..f0bec63
--- /dev/null
+++ b/utilities.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2001-2017 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+#ifndef ISOMD5_UTILITIES_H
+#define ISOMD5_UTILITIES_H
+
+#ifndef _FILE_OFFSET_BITS
+#define _FILE_OFFSET_BITS 64
+#endif
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <sys/types.h>
+
+#include "md5.h"
+
+#ifdef _WIN32
+int getpagesize() { return 2048; }
+#endif
+
+#ifndef O_BINARY
+#define O_BINARY 0
+#endif
+
+#define MAX(x, y) (((x) > (y)) ? (x) : (y))
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+
+#define HASH_SIZE 32
+/* Length in characters of string used for fragment md5sum checking */
+#define FRAGMENT_SUM_SIZE 60UL
+/* FRAGMENT_COUNT must be an integral divisor or FRAGMENT_SUM_SIZE */
+/* 60 => 2, 3, 4, 5, 6, 10, 12, 15, 20, or 30 */
+#define FRAGMENT_COUNT 20UL
+#define SIZE_OFFSET 84
+/* Number of sectors to ignore at end of iso when computing sum. These are
+ * ignored due to problems reading last few sectors on burned CDs. */
+#define SKIPSECTORS 15LL
+/* ISO 9660 magic values. */
+#define SECTOR_SIZE 2048LL
+#define NUM_SYSTEM_SECTORS 16LL
+#define SYSTEM_AREA_SIZE (NUM_SYSTEM_SECTORS * SECTOR_SIZE)
+#define APPDATA_OFFSET 883LL
+#define APPDATA_SIZE 512
+
+struct volume_info {
+    char hashsum[HASH_SIZE + 1];
+    char fragmentsums[FRAGMENT_SUM_SIZE + 1];
+    size_t supported;
+    size_t fragmentcount;
+    off_t offset;
+    off_t isosize;
+    off_t skipsectors;
+};
+
+off_t primary_volume_size(const int isofd, off_t *const offset);
+
+/* Find the primary volume descriptor and return info from it. */
+struct volume_info *const parsepvd(const int isofd);
+
+bool validate_fragment(const MD5_CTX *const hashctx, const size_t fragment,
+                       const size_t fragmentsize, const char *const fragmentsums, char *const hashsums);
+
+void md5sum(char *const hashsum, MD5_CTX *const hashctx);
+
+#endif /* ISOMD5_UTILITIES_H */
-- 
2.14.1

